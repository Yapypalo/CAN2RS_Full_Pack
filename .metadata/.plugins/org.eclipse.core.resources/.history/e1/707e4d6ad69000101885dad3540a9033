#include <string.h>
#include "sensor.h"
#include "uart.h"
#include "can_drv.h"
#include "debug.h"
#include "stm32f1xx_hal.h"

#define PREAMBLE           0xAA
#define MAX_RX             1024
static uint8_t last_req_tick;
static bool awaiting_sensor, awaiting_handshake2;

// простая функция поиска подстроки `pattern[len_p]` внутри `buf[len]`
static bool find_pattern(const uint8_t *buf, int len, const char *pattern, int len_p) {
  for (int i = 0; i + len_p <= len; ++i) {
    if (memcmp(buf + i, pattern, len_p) == 0) return true;
  }
  return false;
}

void SENSOR_Init(void) {
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET);
  awaiting_sensor = awaiting_handshake2 = false;
  last_req_tick = HAL_GetTick();
}

void SENSOR_Process(void) {
  if (UART_PacketReady()) {
    uint16_t plen;
    uint8_t *buf = UART_GetRxBuf(&plen);

    // 1) Ищем ASCII-запросы в любом месте буфера
    if (plen > 0 && buf[0] != PREAMBLE) {
      if (find_pattern(buf, plen, "Работаешь?", 10)) {
        UART_Send((uint8_t*)"Работаю!", 8);
      }
      else if (find_pattern(buf, plen, "А датчик работает?", 19)) {
        // запрашиваем у эмулятора команду 0x04
        uint8_t req04[] = {
          PREAMBLE, 0x01, 0x00, 0,0, 0x04, 0,0
        };
        UART_Send(req04, sizeof(req04));
        awaiting_sensor    = true;
        awaiting_handshake2 = true;
        last_req_tick      = HAL_GetTick();
      }
    }
    // 2) Ищем бинарный фрейм (PREAMBLE) — ответ эмулятора
    else if (plen > 0 && buf[0] == PREAMBLE) {
      if (awaiting_sensor && awaiting_handshake2) {
        // получили ответ на 0x04
        UART_Send((uint8_t*)"И датчик работает", 18);
        awaiting_sensor    = false;
        awaiting_handshake2 = false;
      }
      else {
        // нормальная пересылка в CAN
        CAN_Send(0x100, buf, (plen>8)?8:plen);
      }
    }
  }

  // 3) CAN→UART
  if (CAN_MessagePending()) {
    uint16_t id; uint8_t can_buf[8], can_len;
    CAN_Receive(&id, can_buf, &can_len);
    if (id == 0x200) {
      UART_Send(can_buf, can_len);
      awaiting_sensor = true;
      last_req_tick = HAL_GetTick();
    }
  }

  // 4) тайм-аут сенсора
  if (awaiting_sensor && (HAL_GetTick() - last_req_tick > 500)) {
    DEBUG_Log("Sensor timeout, resetting...\r\n");
    SENSOR_Init();
  }
}
