/* ========================== sensor.c ========================== */
#include "sensor.h"
#include "uart.h"
#include "can_drv.h"
#include "debug.h"
#include "stm32f1xx_hal.h"

#define SENSOR_CAN_TX_ID   0x100
#define SENSOR_CAN_RX_ID   0x200
#define SENSOR_TIMEOUT_MS  500

static uint32_t last_req_tick = 0;
static bool awaiting_response = false;

void SENSOR_Init(void)
{
  // Аппаратный сброс зонда: PB7 – RESET_SENSOR
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET);

  last_req_tick = HAL_GetTick();
  awaiting_response = false;
}

void SENSOR_Process(void)
{
  // 1) Если пришло новое CAN-сообщение – отдать на UART (RS-485)
  if (CAN_MessagePending()) {
    uint16_t can_id;
    uint8_t buf[8];
    uint8_t len;
    CAN_Receive(&can_id, buf, &len);

    // Проверяем фильтр ID, например команд к датчику
    if (can_id == SENSOR_CAN_RX_ID) {
      UART_Send(buf, len);
      awaiting_response = true;
      last_req_tick = HAL_GetTick();
    }
  }

  // 2) Если пришел полный пакет от UART – переслать на шину CAN
  if (UART_PacketReady()) {
    uint16_t plen;
    uint8_t *p = UART_GetRxBuf(&plen);
    CAN_Send(SENSOR_CAN_TX_ID, p, (plen>8)?8:plen);
    awaiting_response = false;
  }

  // 3) Тайм-аута ожидания ответа от зонда
  if (awaiting_response && (HAL_GetTick() - last_req_tick > SENSOR_TIMEOUT_MS)) {
    DEBUG_Log("Sensor timeout, resetting...\r\n");
    SENSOR_Init();
    awaiting_response = false;
  }
}
