// sensor.c
#include "sensor.h"
#include "uart.h"
#include "can_drv.h"
#include "debug.h"
#include "stm32f1xx_hal.h"
#include <string.h>
#include <stdbool.h>

#define PREAMBLE           0xAA
#define SENSOR_CAN_TX_ID   0x100
#define SENSOR_CAN_RX_ID   0x200
#define SENSOR_TIMEOUT_MS  500

extern uint8_t  uart_rx_buf[];
extern DMA_HandleTypeDef hdma_usart1_rx;

static uint32_t uart_last_idx;
static uint32_t last_req_tick;
static bool     awaiting_sensor, awaiting_handshake2;

// вспомогатель: ищем в ascii_buf завершение строки
static bool ascii_find(const char *pat, int pat_len);

void SENSOR_Init(void)
{
  // сброс зонда
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET);
  HAL_Delay(10);
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET);

  uart_last_idx      = UART_RX_BUFSIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);
  awaiting_sensor   = false;
  awaiting_handshake2 = false;
  last_req_tick     = HAL_GetTick();
}

void SENSOR_Process(void)
{
  // 1) Сканируем новые байты в uart_rx_buf
  uint32_t cur_idx = UART_RX_BUFSIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);
  while (uart_last_idx != cur_idx)
  {
    uint8_t b = uart_rx_buf[uart_last_idx++];
    if (uart_last_idx >= UART_RX_BUFSIZE) uart_last_idx = 0;

    static char ac_buf[64];
    static int  ac_len = 0;
    static uint8_t bin_buf[1024];
    static int  bin_len = 0;
    static bool in_bin = false;

    if (!in_bin)
    {
      // текстовая ветка: копим до '\n' или по длине
      if (b >= 32 && b <= 126 && ac_len < (int)sizeof(ac_buf)-1) {
        ac_buf[ac_len++] = b;
      }
      if (b == '\n' || ac_len == (int)sizeof(ac_buf)-1) {
        ac_buf[ac_len] = 0;
        // проверяем команды
        if (ascii_find("Работаешь?", 10)) {
          UART_Send((uint8_t*)"Работаю!", 8);
        }
        else if (ascii_find("А датчик работает?", 19)) {
          // шлём PREAMBLE-запрос 0x04
          uint8_t req04[] = {PREAMBLE, 0x01,0x00,0,0, 0x04,0,0};
          UART_Send(req04, sizeof(req04));
          awaiting_sensor    = true;
          awaiting_handshake2 = true;
          last_req_tick      = HAL_GetTick();
        }
        ac_len = 0;
      }

      // бинарная ветка: старт PREAMBLE?
      if (b == PREAMBLE) {
        in_bin = true;
        bin_buf[0] = b;
        bin_len    = 1;
      }
    }
    else
    {
      // копим бинарник заголовка + длина + данные + CRC
      bin_buf[bin_len++] = b;
      if (bin_len == 8) {
        // после 8-го байта нам известна длина:
        uint16_t dlen = bin_buf[6] | (bin_buf[7]<<8);
        // ждём dlen+2 байта CRC
        if (bin_len >= 8 + dlen + 2) {
          // полный фрейм готов
          if (awaiting_sensor && awaiting_handshake2) {
            UART_Send((uint8_t*)"И датчик работает", 18);
            awaiting_sensor     = false;
            awaiting_handshake2 = false;
          } else {
            // обычная пересылка в CAN (до 8 байт)
            CAN_Send(SENSOR_CAN_TX_ID, bin_buf, (bin_len>8)?8:bin_len);
          }
          in_bin   = false;
          bin_len  = 0;
        }
      }
    }
  }

  // 2) Обработка CAN→UART
  if (CAN_MessagePending()) {
    uint16_t id; uint8_t buf[8]; uint8_t len;
    CAN_Receive(&id, buf, &len);
    if (id == SENSOR_CAN_RX_ID) {
      UART_Send(buf, len);
      awaiting_sensor = true;
      last_req_tick = HAL_GetTick();
    }
  }

  // 3) Таймаут
  if (awaiting_sensor && HAL_GetTick() - last_req_tick > SENSOR_TIMEOUT_MS) {
    DEBUG_Log("Sensor timeout — reset\n");
    SENSOR_Init();
  }
}

// поисковик паттерна внутри последней ASCII-строки
static bool ascii_find(const char *pat, int pat_len)
{
  extern char ac_buf[];
  extern int  ac_len;
  if (ac_len < pat_len) return false;
  for (int i = 0; i + pat_len <= ac_len; ++i)
    if (memcmp(ac_buf+i, pat, pat_len) == 0)
      return true;
  return false;
}
