/* ========================== uart.c ========================== */
#include "stm32f1xx_hal.h"
#include "uart.h"

UART_HandleTypeDef   huart1;
DMA_HandleTypeDef    hdma_usart1_rx;
DMA_HandleTypeDef    hdma_usart1_tx;

// Прием в кольцевой буфер
#define UART_RX_BUFSIZE 1024
static uint8_t uart_rx_buf[UART_RX_BUFSIZE];
static volatile bool packet_ready = false;
static uint16_t packet_len = 0;

void UART_Init(void)
{
  __HAL_RCC_USART1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();

  huart1.Instance          = USART1;
  huart1.Init.BaudRate     = 1000000;
  huart1.Init.WordLength   = UART_WORDLENGTH_8B;
  huart1.Init.StopBits     = UART_STOPBITS_1;
  huart1.Init.Parity       = UART_PARITY_NONE;
  huart1.Init.Mode         = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  HAL_UART_Init(&huart1);

  // Настройка DMA RX
  hdma_usart1_rx.Instance                 = DMA1_Channel5;
  hdma_usart1_rx.Init.Direction           = DMA_PERIPH_TO_MEMORY;
  hdma_usart1_rx.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_usart1_rx.Init.MemInc              = DMA_MINC_ENABLE;
  hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_usart1_rx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_usart1_rx.Init.Mode                = DMA_CIRCULAR;
  hdma_usart1_rx.Init.Priority            = DMA_PRIORITY_HIGH;
  HAL_DMA_Init(&hdma_usart1_rx);
  __HAL_LINKDMA(&huart1, hdmarx, hdma_usart1_rx);

  // Настройка DMA TX
  hdma_usart1_tx.Instance                 = DMA1_Channel4;
  hdma_usart1_tx.Init.Direction           = DMA_MEMORY_TO_PERIPH;
  hdma_usart1_tx.Init.PeriphInc           = DMA_PINC_DISABLE;
  hdma_usart1_tx.Init.MemInc              = DMA_MINC_ENABLE;
  hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  hdma_usart1_tx.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
  hdma_usart1_tx.Init.Mode                = DMA_NORMAL;
  hdma_usart1_tx.Init.Priority            = DMA_PRIORITY_MEDIUM;
  HAL_DMA_Init(&hdma_usart1_tx);
  __HAL_LINKDMA(&huart1, hdmatx, hdma_usart1_tx);

  // Запустить прием DMA в кольцо
  HAL_UART_Receive_DMA(&huart1, uart_rx_buf, UART_RX_BUFSIZE);
  // Настроить прерывание IDLE для разбора пакетов
  __HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
}

void UART_Send(uint8_t *buf, uint16_t len)
{
  // Включить драйвер RS-485
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);
  // Передача по DMA
  HAL_UART_Transmit_DMA(&huart1, buf, len);
}

// Колбэк окончания передачи – сброс DE
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART1) {
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_RESET);
  }
}

// IDLE детекшен – конец пакета
void USART1_IRQHandler(void)
{
  if (__HAL_UART_GET_FLAG(&huart1, UART_FLAG_IDLE)) {
    __HAL_UART_CLEAR_IDLEFLAG(&huart1);
    // Остановим DMA, узнаем сколько приняли
    HAL_UART_DMAStop(&huart1);
    packet_len = UART_RX_BUFSIZE - __HAL_DMA_GET_COUNTER(&hdma_usart1_rx);
    packet_ready = true;
    // Запустим заново
    HAL_UART_Receive_DMA(&huart1, uart_rx_buf, UART_RX_BUFSIZE);
  }
}

bool UART_PacketReady(void) { return packet_ready; }

uint8_t* UART_GetRxBuf(uint16_t *out_len)
{
  packet_ready = false;
  *out_len = packet_len;
  return (uint8_t*)uart_rx_buf;
}
